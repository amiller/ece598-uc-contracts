\documentclass[11pt]{article}
\usepackage[dvipsnames]{xcolor}
\usepackage{fancyhdr}
\usepackage{url}
\usepackage[most]{tcolorbox}
\usepackage{multirow}

\usetikzlibrary{matrix, arrows.meta, calc, positioning}
\tikzset{myarrow/.style={-Latex, rounded corners},}

\definecolor{vert}{RGB}{0,181,0}
\definecolor{oran}{RGB}{223,74,0}
\definecolor{viol}{RGB}{134,0,175}
\definecolor{roug}{RGB}{215,15,0}
\definecolor{bb}{RGB}{0,0,0}

\newtcolorbox[auto counter]{bbox}[2][]{%
    colback=white,
    colframe=bb,
    colbacktitle=white!90!roug,
    coltitle=black,
    fonttitle=\bfseries, 
    enhanced,
    attach boxed title to top left={yshift=-2mm, xshift=0.5cm},%
    #1% For possible options
}
\topmargin=-5mm
\evensidemargin=0cm
\oddsidemargin=0cm
\textwidth=16cm
\textheight=22cm
\addtolength{\headheight}{1.6pt}
\newcommand{\cancel}[1]{}
\newcommand{\mymark}{$^*$}
\setlength\parindent{24pt}

\newcommand{\lastupdate}{August 2015}

\lhead{\sc IACR Policy for Cryptology Schools}
\rhead{\sc \lastupdate}

\title{\bf IACR Policy for Cryptology Schools}
\author{\mbox{}}

\date{\lastupdate
 \footnote{The most recent version of this document
    can be obtained from \protect\url{http://www.iacr.org/docs/}.\newline
  Editors of this document: M. Abdalla, A. Boldyreva, C. Cachin, A. Kiayias, B. Warinschi (2014).}}

\input{macros}

\begin{document}

\pagestyle{fancy}
\pagenumbering{arabic}

\maketitle

\section{Related Works}
\input{sections/relatedworks}

\section{Preliminaries}
\input{sections/prelim}

\begin{figure}[!ht]
	\input{figures/exec_tx}
	\label{fig:functionality:exectx}
\end{figure}

\begin{figure}[!ht]
\input{figures/exec_contract_create}
\label{fig:functionality:execcreate}
\end{figure}

\begin{figure}[!ht]
\input{figures/g_ledger}
	\caption{Ideal functionality representing a basic ledger with adversarial methods for delaying/reordering transactions and smart contract support}
	\label{fig:functionality:ledger}
\end{figure}

\begin{figure}
	\input{figures/protected_wrapper}
	\caption{Protection wrapper for the ledger to maintain indistinguishability.}
\end{figure}

\begin{figure}
	\input{figures/u_pay}
	\caption{Update function for a payment channel. Given as a parameter to \Fstate. It defines the format of the \msf{state} and its updates.}
\end{figure}

\begin{figure}
	\input{figures/contract_pay}
	\caption{Contract pay}
\end{figure}

\begin{figure}
	\input{figures/p_pay}
	\caption{Local protocol for parties to follow for a payment channel between two parties. Parties can pay, deposit into, or withdraw from the channel.}
\end{figure}

\begin{figure}
	\input{figures/f_state}
	\caption{The ideal functionality \Fstate. The functionality proceeds in rounds and waits for parties to provide input. When all parties have provided input or the round deadline has passed, a state update is executed. Contract output is given to \Gledger in the form of a transaction. Parties must explicitly \msf{ping} the functionality in order to make progress. }
\end{figure}

\begin{figure}
	\input{figures/f_pay}
	\caption{The payment channel functionality. Unlike $\Fstate$, doesn't need any notion of rounds until it must deal with on-chain transactions for deposits. Buffering for $O(\Delta)$ rounds implies the adversary can choose the number.}
\end{figure}

\begin{figure}
	\input{figures/wrapper}
	\caption{The wrapper $\mathcal{W}$ that provides common function for all functionalities. In $\Fstate$ for example, the wrapper enables functionalities to buffer sending output to the parties in the protocol. When the wrapper sends a message to its functionality $\F$, it does not constitute an \msf{ITM} to \msf{ITM} write as they are both running on the same \msf{ITM}.}
\end{figure}

\begin{figure}
	\input{figures/f_broadcast}
\end{figure}

\begin{figure}
	\input{figures/g_clock}
\end{figure}

\begin{figure}
	\input{figures/state_prot}
\end{figure}

\section{Three-Phase Commitment}

\subsection{Synchronous Bracha Broadcast}

\begin{figure}[!h]
	\input{figures/f_katz}
\end{figure}
%\begin{figure}
%	\input{figures/sim_bracha}
%\end{figure}
\begin{figure}[!h]
	\input{figures/f_bracha}
\end{figure}
\begin{figure}[!h]
	\input{figures/prot_bracha}
\end{figure}

{\bf Theorem.} {\em Protocol $\Pi_{\msf{Bracha}}$ securely realized $\F_{\msf{Bracha}}$ in the $\{\F_{\msf{BD-SEC}},\F_{\msf{CLOCK}}\}$-hybrid world. Assume a stateic adversary corrupted up to $\frac{n}{3}$ parties.}

Consider the simulator, $\mathcal{S}$, above.

If the dealer $\mathcal{D}$ is honest: In the ideal world, $\mathcal{D}$ gives input $v$ to $\F_{\msf{Bracha}}$ which gives leaks it to $\mathcal{S}$.
The simulator submits the input to it all of the locl $\Fsync{\mathcal{D}}{p_i}$ for $p_i \in  \mathcal{P}$.

$\mathcal{S}$ expects to receive $|\mathcal{P}|$ activations from $\F_{\msf{Bracha}}$ when ideal world parties attempt to read output from the functionality.
In each activation, the simulator sufficiently ensures each party reads messages from all other parties and simualated state changes and increment the local $\overline{\mathcal{F}}_{\msf{clock}}$

The functionality waits $Rnd = 3$ rounds to deliver the output. In the first round $|\mathcal{P}|^2$ activations ensure all \msf{ECHO} messages are sent.
In functionality round 2, activations ensure that all \msf{READY} messages are sent. The final functionality round 3, all \msf{READY}s are delivered and the simulates real world parties all output a value $v$.
By the proof of the Bracha protocol, all real world parties output the same value. The simulator instructs 
\subsection{Extra}

\begin{figure}
	\input{figures/f_clock}
\end{figure}

\begin{figure}
	\input{figures/f_3pc}
\end{figure}

%\begin{bbox}[title=asd]
%hello
%\end{bbox}


\bibliographystyle{plain}
\emergencystretch 1.5em
\bibliography{bibuccontracts}


\end{document}
