\begin{bbox}[title={\textbf{Wrapper} $\mathcal{W}_{\msf{sync}}$}]

Initialize $\msf{leakbuffer} := \emptyset, \msf{runqueue} := \emptyset, r := 0, delay := 0$

\vspace{2mm} \hrule \vspace{2mm}

-- \OnInput \inmsg{schedule}{codeblock $e$, $\delta$} $1 \token$ from $\mathcal{F}_i$/$P_i$:

	\qquad $idx \leftarrow$ append $e$ to $\msf{runqueue}[r+ \delta]$

	\qquad $delay = delay + 1$

	\qquad Append (schedule, $r + \delta$, $idx$) to \msf{leakbuffer}

	\qquad \Send (scheduled) $\rightarrow \mathcal{F}_i/P_i$

-- \OnInput \inmsg{delay} $d \token$ from $\mathcal{A}$:

	\qquad $delay = delay + d$

-- \OnInput \inmsg{execute}{$rnd$}{$idx$} from $\mathcal{A}$:
	
	\qquad $e \leftarrow$ pop $\msf{runqueue}[r][idx]$

	\qquad Execute $e$

-- \OnInput \inmsg{leak}{msg} from $\mathcal{F}_i/P_i$:

	\qquad Append $(msg, \mathcal{F}_i/P_i, d \token)$ to $\msf{leakbuffer}$

-- \OnInput \inmsg{poll} $1 \token$ from $\mathcal{Z}$:

	\qquad \If $delay > 0$:

		\qqquad $delay = delay - 1$

		\qqquad \Send (poll) to $\mathcal{A}$
	
	\qquad Else: 

		\qqquad $rnd \leftarrow \msf{argmin}_{r}\{ \msf{runqueue}[r] \neq \emptyset \}$

		\qqquad $e \leftarrow$ pop $\msf{runqueue}[rnd]$

		\qqquad Execute $e$

-- \OnInput \inmsg{round} from $\mathcal{F}_i/P_i$:

	\qquad \Send $r \rightarrow \mathcal{F}_i/P_i$

-- \OnInput \inmsg{getleaks} from $\mathcal{A}$:

	\qquad $d \leftarrow$ total import in $\msf{leakbuffer}$

	\qquad \Send $(\msf{leakbuffer}, d \token) \rightarrow \mathcal{A}$

	\qquad $\msf{leakbuffer} = \emptyset$

\end{bbox}
