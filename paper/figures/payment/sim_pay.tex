\newcommand{\idealqueue}{{\color{Blue} \msf{idealqueue} }}
\newcommand{\simadv}{\ensuremath{\mathcal{D}}}
\newcommand{\idealdelay}{{\color{Blue} \msf{idealdelay} }}
\newcommand{\nonce}{{\color{Blue} \msf{nonce} }}
\newcommand{\state}{{\color{Blue} \msf{state} }}
\newcommand{\simleaks}{{\color{Blue} \msf{leaks} }}

\begin{bbox}[title={$\mathcal{S}_{pay}(P_s, P_r, b_r, b_s)$}]

Simulate real world parties $P_s', P_r'$, dummy adversary $\mathcal{D}'$, wrapper $\Wsync'$,
functionality $\F_{contract}$.

Initialize $\state = (b_s, b_r, 0)$, $\nonce = 0$, $\simleaks = \emptyset$, $\idealdelay=0$, $\idealqueue = \emptyset$

\underline{On every activation:}
	\begin{renumerate}
		\item $leaks \leftarrow \{ \Send (\msf{getleaks}) \rightarrow \mathcal{W}_{sync}\}$
		%\item $output = []$

		\item All leaks, \msf{pay} and \msf{close}, are followed by the leak of their (schedule) operation, and ideal functionality guarantees \msf{close} occurs only once and after the last \msf{pay}:
		\begin{renumerate}
			\item For each (pay, $v$) leak:
			\begin{renumerate}
				\item Update \nonce and \state to reflect the new payment 
				and saved the $rnd$,$idx$ of the corresponding (schedule) leak into 
				\idealqueue. Increment \idealdelay.
				
				\item Simulate (pay, $v$) $\rightarrow P_s'$.
			\end{renumerate}

			\item For each (close, $b_s'$, $b_r'$, $P_i$) leak:
			\begin{renumerate}
				\item Save $rnd$, $idx$ for both $P_r$ and $P_s$ in the following (schedule) 
				leaks into \idealqueue. Add $\idealdelay \pluseq 2$.

				\item Simulate (close) $\rightarrow P_i'$
			\end{renumerate}
		\end{renumerate}

		\item Execute \msf{SimGetLeaks} 

	\end{renumerate}

\vspace{2mm} \hrule \vspace{2mm}

\end{bbox}
