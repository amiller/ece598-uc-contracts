\begin{bbox}[title={Simulator $\mathcal{S}_{bracha} (\mathcal{D}, \mathcal{P}, \Delta)$}]

Simulate real world parties $p_1',...,p_n'$ and the simulated dealer $\mathcal{D}'$.

Initialize $\msf{idealqueue} := \emptyset, idealdelay := 0$

\vspace{2mm} \hrule \vspace{2mm}

\OnInput \inmsg{\texttt{get-leaks}} from $\mathcal{Z}$:
	\begin{renumerate}
	\item $leaks \leftarrow$ \{ \Send (\texttt{get-leaks}) $\rightarrow \mathcal{W}_{sync}$\}

	\item \For $l \in leaks$:
		\begin{renumerate}
		\item \If $l$ is (input, v), $n(4n+1) \token$ from $\F_{bcast}$:

			\quad Simulate (input, $v$, $n(4n+1) \token$) $\rightarrow \mathcal{D}'$ 

		\item \Else \If $l$ is (schedule, $rnd$, $idx$) from $\F_{bcast}$:

			\quad Map $p_i$ to $(rnd,idx)$ for the $i$th such leak.

			\quad $idealdelay = idealdelay + 1$

		\item \Else:

			\quad $idealdelay = idealdelay + 1$
		\end{renumerate}
	%\qquad $leaks \leftarrow$ \{ \Send (\texttt{get-leaks}) $\rightarrow \mathcal{W}_{sync}'$\}
	\item $leaks \leftarrow \msf{SimGetLeaks}$

	\item \Send $leaks \rightarrow \mathcal{Z}$
	\end{renumerate}

\OnInput \inmsg{poll} from $\mathcal{Z}$:
	\begin{renumerate}
	\item execute \msf{Poll}
	\end{renumerate}

\OnInput \inmsg{delay}{$d \token$} from $\mathcal{Z}$:
	\begin{renumerate}
	\item Simulate $(delay, d \token) \rightarrow \mathcal{W}_{sync}'$

	\item \Send $(\texttt{delay}, d \token) \rightarrow \mathcal{W}_{sync}$

	\item $idealdelay = idealdelay + d$
	\end{renumerate}

\OnInput \inmsg{exec}{$rnd$}{$idx$} from $\mathcal{W}_{sync}$:
	\begin{renumerate}
	\item Simulate $(\texttt{exec}, rnd, idx) \rightarrow \mathcal{W}_{sync}'$

	\item Forward any messages from a simulated part $p_i'$ or $\mathcal{A}'$
	\end{renumerate}

\end{bbox}
