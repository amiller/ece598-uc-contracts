\subsection{Broadcast in Katz et al.}

In this section we describe the ideal functionality and protocol for a simple byzantine broadcast in the synchronous model.
The function is modelled after the secure function evaluation functionality, $\F_{\msf{SFE}}^{f,Rnd}$, described in ~\cite{katz-clock}.
Secure function evaluation computes the output of a single function from the inputs of the parties.
The function being evaluated must be computable in one round in the ideal world, meaning parties don't have to give input more than once.
In our case, the ideal function for a byantine broadcast, $f$ (shown below), with a dealier, $\mathcal{D}$, just selects the dealer's input.

\[ f_{bc}(x_1,...,x_n) := x_{\mathcal{D}} \]

The functionality proceeds in rounds, $l$, until $Rnd$ rounds have elapsed.
At the end of $Rnd$ rounds it computes the function $f$ on the inputs of all parties that have provided input and sends output to each of them.
In every round, the functionality requires the environment to activate each party at least $|\mathcal{P}|$ times before increenting the round $l$. 
Everytime a party is activated by a party asking for \msf{output}, the functionality activates the the simulator.
With $n$ activations, the simulator can sufficiently simulate the real world protocol and use the activations provdided by the functionality, to activate and perform computation.
For example, for a party $p_i$, on activation $k$ within a round, the simulator simulates $p_i$'s interaction with party $p_k$ in the real world.
It will read messages from $p_k$ to $p_i$, perform any local computation, and potentially send messages to $p_k$ for subsequent rounds.

Similarly, such a structure design must also be present in the real world, where the environment will provide the same $n$ \msf{output} to each itm.

\begin{figure}[!h]
	\input{figures/f_bracha_high}
	\label{fig:functionality:broadcast_high}
	\caption{The ideal functionality for the synchronous Byzantine broadcast protocol from~\cite{bracha}. This functionality abstracts away UC-related details for clarity. This description of the functionality will actually be compiled to the functionality below which is how the program be written to adhere to the UC framework.}
\end{figure}

\begin{figure}[!h]
	\input{figures/f_bracha}
	\label{fig:functionality:broadcast}
	\caption{Ideal functionality for a byzantine broadcast. The ideal functionality is not specific to any potential real world protocol, but captures the guarantees of the broadcast. Additionally, the functionality is identical to the SFE functionality except for assumptions made for the application at hand.}
\end{figure}

The ideal functionality of for byzantine broadcast is described in Figure ~\ref{fig:functionality:broadcast}
The functionality is cast as a secure function evaluation where the function is as described above.
In our case we simplify the SFE functionality instead of just parmeterizing it with the function $f_{\msf{bc}}$ gives its simplicity.
The only simplification made to SFE is that the functionality only waits for the dealer's input (in SFE this equates to assuming all other parties' inputs are already set).
Furthermore, the function $f_{\msf{BC}}$ is put in place in the functionality.

\begin{figure}
	\input{figures/async_bracha}
	\label{fig:protocol:asyncbracha}
	\caption{The original asynchronous broadcast protocol proposed by Bracha~\cite{bracha-broadcast}. The protocol proceeds in three rounds and terminates if enough messages are delivered.}
\end{figure}

Next we introduce a real world protocol that realized the ideal functionality.
We use the asynchronous broadcast primitive introduced by Bracha~\cite{bracha-broadcast} that tolerates $\frac{n}{3}$ byzantine failures.
Below, we introduce the same broadcast protocol cast in the synchronous model.
We modify the protocol in the following ways:

\begin{itemize}
	\item First, the protocol has to be updates to reflect the interace offered by the ideal functionality. In the ideal world, the environment gives $|\mathcal{P}|$ activations to each party in each round. In the real world protocol, on the first activation of a party in a round $r$, the party $p_i$ fetches incoming messages from previous rounds, computes the messages to be sent in this round, $\{m_{i,j,r}\}_{j}$, and uses the next $|\mathcal{P}|$ rounds to send those messages to the other parties.
	\item Second, the protocol is modified to only accept certain messages in certain rounds. For example, the hones dealer will only accept $(input,v)$ from the environment in the first round, all parties will only accept $(VAL,v)$ messages in the second tound, and so on.
\end{itemize}

\begin{figure}[!h]
	\input{figures/prot_bracha}
\end{figure}
\begin{figure}
	\input{figures/sim_bracha}
\end{figure}

{\bf Theorem.} {\em Protocol $\Pi_{\msf{Bracha}}$ securely realized \Fbc in the $\{\Fbdsec,\Fclock \}$-hybrid world. Assume a stateic adversary corrupted up to $\frac{n}{3}$ parties.}

Consider the simulator, $\mathcal{S}$, above.

If the dealer $\mathcal{D}$ is honest: In the ideal world, $\mathcal{D}$ gives input $v$ to $\F_{\msf{Bracha}}$ which gives leaks it to $\mathcal{S}$.
The simulator submits the input to it all of the locl $\Fsync{\mathcal{D}}{p_i}$ for $p_i \in  \mathcal{P}$.

$\mathcal{S}$ expects to receive $|\mathcal{P}|$ activations from $\F_{\msf{Bracha}}$ when ideal world parties attempt to read output from the functionality.
In each activation, the simulator sufficiently ensures each party reads messages from all other parties and simualated state changes and increment the local \Fclock.

The functionality waits $Rnd = 3$ rounds to deliver the output. In the first round $|\mathcal{P}|^2$ activations ensure all \msf{ECHO} messages are sent.
In functionality round 2, activations ensure that all \msf{READY} messages are sent. The final functionality round 3, all \msf{READY}s are delivered and the simulates real world parties all output a value $v$.
By the proof of the Bracha protocol, all real world parties output the same value. The simulator instructs 

\paragraph{Typo in Katz paper}
In synchronous protocols, parties can send at most $n = |\mathcal{P}|-1$ messages, one message to each other participant in the protocol.
According to the functionality $\Fbdsec$, when a party sends a message, the adversary is activated by leaking information.
This means that in one activation, each party can only send one message.
The definition of synchronous protocols in the $\{\Fbdsec,\Fclock \}$-hybrid says that in each round each party must send (\texttt{RoundOK}) to $\Fclock$.
Therefore, each party needs $n$ activations, $n-1$ for sending messages and 1 for sending \texttt{RoundOK}.
Finally, any subsequent activation if $p_i$'s bit $d_i$ is still 1, $p_i$ outputs \texttt{early} to the environment.
The ideal world needs these many acivations as well, to invoke the simulator enough to simulate the real world.

The functionality as described in the paper, show in Figure~\ref{fig:sfe} allows the round to advance with only $n-1$ activations through the \texttt{output} message.
The edit to make is to change the \texttt{activated} and \texttt{early} logic to wait until $t_i = 0$ instead of 1. That's all.


\begin{figure}
	\input{figures/f_sfe}
	\label{fig:sfe}
	\caption{The ideal functionality for secure function eveluation from Katz~\cite{synchronousuc}. It's parameterized by the function $f$ and a polynomial $Rnd$ representing the upper bound on the number of rounds the real world protocol takes. It proceeds in rounds where eact party requires $|\mathcal{P}|$ activations. And it's WRONG.}
\end{figure}

Below is the updated version with the correct number of activations.

\begin{figure}
	\input{figures/f_sfe_new}
	\label{fig:sfe}
	\caption{Same ideal functionality as Figure~\ref{fig:sfe} but corrected}
\end{figure}

\begin{figure}
	\input{figures/katz_wrapper}
	\label{fig:wrapper}
\end{figure}

\newpage

\subsection{Broadcast with Synchronous Wrapper}
This section descibres how the synchronous wrapper works.
The example is bracha broadcast with the functionalities, protocols, simulator and wrapper listed below.

\paragraph{Synchronous Wrapper}
The synchronous wrapper handles delaying execution of codeblocks within a upper bound $\Delta$ that is fixed by the calling protocol. 
The synchronous wrapper provides a simple interface to the parties and functionalities, defined in Figure~\ref{fig:wrapper:synchronous}.
The simplest example to demonstrate how the wrapper works is with a simple synchronous, point-to-point channel, $\F_{sync-chan}$ (Figure~\ref{fig:functionality:channel}).

In order to deliver an output, send a message, or execute an arbitrary code block with in a certain number of clock rounds, an ITM can ``schedule'' a piece of code to execute within a number of rounds.
In the definition of $\F_{sync-chan}$ in Fig~\ref{fig:functionality:channel}, a message needs to be delivered to the recipient in a synchrous manner so the functionality schdules the code block with the wrapper (for simplicty, we show two version of the same p2p channel: (a) one where the intuitive notion of synchronous code execution is captures and (b) where we show the actual messages passed from the functionality and the wrapper). 

\begin{figure}
	\input{figures/f_channel}
	\caption{A basic point-to-point channel functionality that delivers the message in a synchronous way.}
	\label{fig:functionality:channel}
\end{figure}

When a codeblock is schedule in the wrapper, it is immediately assigned the maximum possibe delay and added to the queue of schedule codeblocks.
The adversary is made aware of the round and the index into the queue for this new codeblock.
Additionally, a delay of 1 is added to the internal delay of the wrapper.
Once schedule, there are two ways for the code block to eventually be executed.
The first way is the adversary can decide to send the (\texttt{exec},$rnd$,$idx$) message to the wrapper to force the execution of a code block whenever it wants.
The second, method is through the environment polling the wrapper.
The purpose of allowing the environmen to force the wrapper to execute codeblocks is to prevent the adversary from having complete control over the wrapper and stop rounds from progressing.

\paragraph{Polling}
When the environment polls the wrapper, it decrements a delay counter (recall the delay is incremented when a new codeblock is schedule and can be further delayed by the adversary).
After sufficient polling, the delay reaches 0 in round $r$ and the next available code-block is popped from the queue and executed. 
The wrapper skips ahead to the first round $r' \geq r$ that contains a codeblock to execute.

\begin{figure}
	\input{figures/wrapper}
	\caption{This wrapper implements the enhancements made to the protocol to conform to the interace of the ideal functionality \Fbc. It reads in incoming messages in the first activation of a round and uses the next $|\mathcal{P}|$ activations to send messages to others.}
	\label{fig:wrapper:synchronous}
\end{figure}

The Bracha broacast protcol is shown in Figure~\ref{fig:prot_bracha_ours}. 
The protocol proceeds in a few rounds where VAL, ECHO, and READY messages exchanged until parties are ready to commit to a dealer input value $v$.
The corresponding functionality in Figure~\ref{fig:functionality:broadcast_import_real} is $\F_{bcast}$.

\paragraph{Bracha Simulator}
The simulator runs a local simulation of the real world protocol with the same honest and corruptd parties as the real world. It also runs a local simulation of the synchronous wrapper in the real world.

When the dealer in is honest, $\F_{bcast}$ leaks the input to the dealer as well as the import received and gives it to \Wsync.
When the environment asks the simulator to get leaks from the wrapper, the simulator firsts obtains the honest dealer's input and passes it to the simulated real world dealer and simulates all following messages.
It also gets leaks of new codeblocks scheduled to execute in \Wsync and internall tracks them with the $idealdelay$ parameter. 
The simulator needs to track this value internall to ensure that the codeblocks delivering output in the real world are not executed until their counterparts in the simulation real-world also execute.
After simulating the input, the simulator collets the leaks from the simuated wrapper \Wsync' and returns them to the environment.


\begin{figure}
\begin{subfigure}{\textwidth}
	\input{figures/f_broadcast_import}
	\label{fig:functionality:broadcast_import}
	\caption{A simple broadcast functionality that delivers the output to all the other parties within $O(\Delta)$ rounds. The functionality is described at a high level, with more specific messages and wrapper interaction shown below.}
\end{subfigure}
\newline
\begin{subfigure}{\textwidth}
	\input{figures/f_broadcast_import_real}
	\label{fig:functionality:broadcast_import_real}
	\caption{This broacsat functionality illustrates the actual messages being passed between the functionality above and the wrapper. The wrapper handles synchronous delivery of messages {\em and} leaks.}
\end{subfigure}
\end{figure}

\begin{figure}
	\input{figures/prot_bracha_ours}
	\label{fig:prot:bracha_ours}
\end{figure}

\begin{figure}
	\input{figures/sim_bracha_ours/sim.tex}
	\label{fig:sim:bracha_ours}
\end{figure}

\begin{figure}
	\begin{subfigure}{\textwidth}
	\input{figures/sim_bracha_ours/algo_simgetleaks}
	\label{fig:algo:simgetleaks}
	\caption{Function to get leaks from the simulated real world and update the delay of the ideal world if new codebloks have been schedules in the simulated wrapper, $\mathcal{W}_{sync}'$.}
	\end{subfigure}
	\newline
	\begin{subfigure}{\textwidth}
	\input{figures/sim_bracha_ours/algo_poll}
	\label{fig:algo:poll}
	\caption{Function that forwards a (\texttt{poll}) message to the simulated wrapper and waits for a message back from a simulated party or the adversary. If an output is given from a party and the fnuctionality, $\F_{bcast}$ functionality did not leak an input, the dealer is corrupt. Therefore, the simulator gives input to $\F_{bcast}$ and delivers that party's output.}
	\end{subfigure}
\end{figure}
