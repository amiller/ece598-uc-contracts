\subsection{Unidirectional Payment Channels}

In the unidirectional channel there are two parties, $P_s$ and $P_r$, where only the ``sender'' $P_s$ is sending payments to $P_r$.
The incentive structure in this case is simpler than bi-directional payments because one of the two paties, the receiver, has an incentive to always close with the most recent state of the channel.
Therefore, we consider the receiver's request to close the channel a ``cooperative close''. 
When the sender wants to close the channel, it can tell the receiver and submit a state signed by both of them---also a ``cooperative close''.
Otherwise, it submits a balance signed by only itself and initiates an ``uncooperative close''.

Assumptions:
\begin{itemize}
  \item The channels are already open and the protocol is parameterized by the initial balances of the two parties
  \item ``on chain'' operations like close and settle take O(delta) rounds through a smart contract and atomic broadcast
  \item ``off chain'' communication is instant, i.e. O(1) rounds to send message
  \item contract outputs are broadcast immediately
  \item ``cooperative close'' is only one on-chain operation, so takes O(delta)
  \item ``uncooperative close'' is (1. sender submits state and starts disute, 2. receiver can counter with later state and channel is settled): O(2*delta)
\end{itemize}


%\begin{figure}[!htb]
%	\input{figures/payment/f_atomic}
%	\caption{Permissioned atomic broadcast parameterized by contract code $C$.}
%\end{figure}
\begin{figure}[!htb]
	\input{figures/payment/contract_wrapper}
\end{figure}

\begin{figure}[!htb]
	\input{figures/payment/contract_pay}
\end{figure}

\begin{figure}[!htb]
	\input{figures/payment/f_pay}
\end{figure}

\begin{figure}[!htb]
	\input{figures/payment/prot_pay}
\end{figure}

\begin{figure}[!htb]
	\input{figures/payment/sim_pay}
\end{figure}

\begin{figure}
	\begin{subfigure}{\textwidth}
		\input{figures/payment/algo_simgetleaks}
	\end{subfigure}
	\newline
	\begin{subfigure}{\textwidth}
		\input{figures/payment/algo_poll}
	\end{subfigure}
\end{figure}
%\begin{figure}[h]
%	\input{figures/u_pay}
%	\caption{Update function for a payment channel. Given as a parameter to \Fstate. It defines the format of the \msf{state} and its updates.}
%\end{figure}
%
%\begin{figure}[h]
%	\input{figures/contract_pay}
%	\caption{Contract pay}
%\end{figure}
%
%\begin{figure}[h]
%	\input{figures/p_pay}
%	\caption{Local protocol for parties to follow for a payment channel between two parties. Parties can pay, deposit into, or withdraw from the channel.}
%\end{figure}
%
%\begin{figure}[h]
%	\input{figures/f_state}
%	\caption{The ideal functionality \Fstate. The functionality proceeds in rounds and waits for parties to provide input. When all parties have provided input or the round deadline has passed, a state update is executed. Contract output is given to \Gledger in the form of a transaction. Parties must explicitly \msf{ping} the functionality in order to make progress. }
%\end{figure}
%
%\begin{figure}[h]
%	\input{figures/f_pay}
%	\caption{The payment channel functionality. Unlike $\Fstate$, doesn't need any notion of rounds until it must deal with on-chain transactions for deposits. Buffering for $O(\Delta)$ rounds implies the adversary can choose the number.}
%\end{figure}

